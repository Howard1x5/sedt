#!/bin/bash
# Pre-commit hook to scan for private/sensitive information
# Prevents accidental commits of credentials, IPs, personal paths, etc.

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${YELLOW}[Security Check] Scanning staged files for private information...${NC}"

# Get list of staged files (excluding deleted files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=d)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}No files staged for commit.${NC}"
    exit 0
fi

ISSUES_FOUND=0
WARNINGS=""

# Patterns to check (add your own as needed)
declare -A PATTERNS

# === IP Addresses ===
PATTERNS["Private IP (10.x.x.x)"]='10\.[0-9]+\.[0-9]+\.[0-9]+'
PATTERNS["Private IP (172.16-31.x.x)"]='172\.(1[6-9]|2[0-9]|3[01])\.[0-9]+\.[0-9]+'
PATTERNS["Private IP (192.168.x.x)"]='192\.168\.[0-9]+\.[0-9]+'

# === STRICT BLOCKS (cannot be bypassed with NOSEC) ===
# Operational network subnets that should NEVER appear in public code
declare -A STRICT_BLOCKS
STRICT_BLOCKS["Operational subnet 10.98.x.x"]='10\.98\.[0-9]+\.[0-9]+'

# === API Keys & Tokens ===
PATTERNS["Anthropic API Key"]='sk-ant-api[a-zA-Z0-9_-]+'
PATTERNS["OpenAI API Key"]='sk-[a-zA-Z0-9]{20,}'
PATTERNS["AWS Access Key"]='AKIA[0-9A-Z]{16}'
PATTERNS["AWS Secret Key"]='aws_secret_access_key\s*[:=]\s*["\x27]?[A-Za-z0-9/+=]{40}'
PATTERNS["GitHub Token"]='gh[pousr]_[A-Za-z0-9_]{36,}'
PATTERNS["GitLab Token"]='glpat-[A-Za-z0-9_-]{20,}'
PATTERNS["Slack Token"]='xox[baprs]-[0-9]{10,}-[A-Za-z0-9]+'
PATTERNS["Discord Token"]='[MN][A-Za-z0-9]{23,}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{27}'
PATTERNS["Generic API Key"]='api[_-]?key["\x27]?\s*[:=]\s*["\x27][a-zA-Z0-9]{16,}'

# === Credentials ===
PATTERNS["Password in code"]='password\s*[:=]\s*["\x27][^"\x27]{4,}'
PATTERNS["Generic Secret"]='secret[_-]?key["\x27]?\s*[:=]\s*["\x27]'
PATTERNS["Basic Auth Header"]='Authorization:\s*Basic\s+[A-Za-z0-9+/=]+'
PATTERNS["Bearer Token"]='Authorization:\s*Bearer\s+[A-Za-z0-9._-]+'

# === Private Keys ===
PATTERNS["RSA Private Key"]='-----BEGIN RSA PRIVATE KEY-----'
PATTERNS["OpenSSH Private Key"]='-----BEGIN OPENSSH PRIVATE KEY-----'
PATTERNS["PGP Private Key"]='-----BEGIN PGP PRIVATE KEY BLOCK-----'
PATTERNS["EC Private Key"]='-----BEGIN EC PRIVATE KEY-----'
PATTERNS["Generic Private Key"]='-----BEGIN [A-Z ]+ PRIVATE KEY-----'

# === Database & Connection Strings ===
PATTERNS["PostgreSQL URL"]='postgres(ql)?://[^:]+:[^@]+@'
PATTERNS["MySQL URL"]='mysql://[^:]+:[^@]+@'
PATTERNS["MongoDB URL"]='mongodb(\+srv)?://[^:]+:[^@]+@'
PATTERNS["Redis URL"]='redis://[^:]+:[^@]+@'
PATTERNS["Database Connection"]='(jdbc|odbc):[^"\x27\s]+'

# === Cloud Provider Specific ===
PATTERNS["GCP Service Account"]='\"type\":\s*\"service_account\"'
PATTERNS["Azure Client Secret"]='azure[_-]?client[_-]?secret\s*[:=]'

# === Personal/Local Paths ===
PATTERNS["Personal home path"]='/home/[a-zA-Z0-9_-]+/'
PATTERNS["Windows User Path"]='C:\\\\Users\\\\[A-Za-z0-9]+\\\\'
PATTERNS["macOS User Path"]='/Users/[a-zA-Z0-9_-]+/'

# Files to always skip
SKIP_FILES=".env.example|requirements.txt|\.md$|\.json$|pre-commit"

for FILE in $STAGED_FILES; do
    # Skip binary files and certain file types
    if echo "$FILE" | grep -qE "$SKIP_FILES"; then
        continue
    fi

    # Skip if file doesn't exist (deleted in working tree)
    if [ ! -f "$FILE" ]; then
        continue
    fi

    # Get the staged content (what will actually be committed)
    CONTENT=$(git show ":$FILE" 2>/dev/null)

    if [ -z "$CONTENT" ]; then
        continue
    fi

    # First check STRICT_BLOCKS (no NOSEC bypass allowed)
    for PATTERN_NAME in "${!STRICT_BLOCKS[@]}"; do
        PATTERN="${STRICT_BLOCKS[$PATTERN_NAME]}"
        MATCHES=$(echo "$CONTENT" | grep -nE "$PATTERN" 2>/dev/null || true)

        if [ -n "$MATCHES" ]; then
            ISSUES_FOUND=1
            WARNINGS+="\n${RED}[BLOCKED] $FILE - Found: $PATTERN_NAME (NOSEC bypass NOT allowed)${NC}\n"
            while IFS= read -r line; do
                WARNINGS+="    Line: $line\n"
            done <<< "$MATCHES"
        fi
    done

    for PATTERN_NAME in "${!PATTERNS[@]}"; do
        PATTERN="${PATTERNS[$PATTERN_NAME]}"

        # Search in staged content (excluding lines with NOSEC or MALWARE-IOC marker)
        MATCHES=$(echo "$CONTENT" | grep -nE "$PATTERN" 2>/dev/null | grep -v "NOSEC\|MALWARE-IOC" || true)

        if [ -n "$MATCHES" ]; then
            # Skip common placeholder values that are OK
            if [[ "$PATTERN_NAME" == *"192.168"* ]]; then
                # Allow common placeholder IPs (192.168.1.1, 192.168.1.100, 192.168.0.1)
                REAL_MATCHES=$(echo "$MATCHES" | grep -vE '192\.168\.[01]\.(1|100|0)' || true)
                if [ -z "$REAL_MATCHES" ]; then
                    continue
                fi
                MATCHES="$REAL_MATCHES"
            fi

            # Skip example/placeholder patterns in documentation
            if [[ "$PATTERN_NAME" == *"API Key"* ]] || [[ "$PATTERN_NAME" == *"Token"* ]]; then
                # Skip obvious placeholders like "your_api_key_here", "sk-xxx", etc.
                REAL_MATCHES=$(echo "$MATCHES" | grep -vE '(your_|xxx|example|placeholder|CHANGEME|TODO)' || true)
                if [ -z "$REAL_MATCHES" ]; then
                    continue
                fi
                MATCHES="$REAL_MATCHES"
            fi

            # Skip Windows path in documentation examples
            if [[ "$PATTERN_NAME" == *"Windows User Path"* ]]; then
                REAL_MATCHES=$(echo "$MATCHES" | grep -vE 'C:\\\\Users\\\\(analyst|user|Administrator)\\\\' || true)
                if [ -z "$REAL_MATCHES" ]; then
                    continue
                fi
                MATCHES="$REAL_MATCHES"
            fi

            ISSUES_FOUND=1
            WARNINGS+="\n${RED}[!] $FILE - Found: $PATTERN_NAME${NC}\n"
            while IFS= read -r line; do
                WARNINGS+="    Line: $line\n"
            done <<< "$MATCHES"
        fi
    done
done

# Also check for any env files being committed
ENV_FILES=$(echo "$STAGED_FILES" | grep -E "^\.env$|\.env\.local|\.env\.production" || true)
if [ -n "$ENV_FILES" ]; then
    ISSUES_FOUND=1
    WARNINGS+="\n${RED}[!] CRITICAL: Attempting to commit .env file(s):${NC}\n"
    for f in $ENV_FILES; do
        WARNINGS+="    - $f\n"
    done
fi

if [ $ISSUES_FOUND -eq 1 ]; then
    echo -e "\n${RED}========================================${NC}"
    echo -e "${RED}  PRIVATE INFORMATION DETECTED!${NC}"
    echo -e "${RED}========================================${NC}"
    echo -e "$WARNINGS"
    echo -e "${YELLOW}Options:${NC}"
    echo -e "${YELLOW}  1. Redact/defang the sensitive data${NC}"
    echo -e "${YELLOW}  2. Add '# NOSEC' or '# MALWARE-IOC' comment to the line${NC}"
    echo -e "${YELLOW}  3. Bypass with: git commit --no-verify${NC}"
    echo ""
    exit 1
else
    echo -e "${GREEN}[OK] No private information detected in staged files.${NC}"
    exit 0
fi
